// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package something

import (
	"reflect"
	"strings"

	di "github.com/fluffy-bunny/sarulabsdi"
	"github.com/rs/zerolog/log"
)

// ReflectTypeISomething used when your service claims to implement ISomething
var ReflectTypeISomething = di.GetInterfaceReflectType((*ISomething)(nil))

// AddSingletonISomething adds a type that implements ISomething
func AddSingletonISomething(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SINGLETON", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonISomethingWithMetadata adds a type that implements ISomething
func AddSingletonISomethingWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SINGLETON", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonISomethingByObj adds a prebuilt obj
func AddSingletonISomethingByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SINGLETON", reflect.TypeOf(obj), _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "obj",
		})
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonISomethingByObjWithMetadata adds a prebuilt obj
func AddSingletonISomethingByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SINGLETON", reflect.TypeOf(obj), _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "obj",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonISomethingByFunc adds a type by a custom func
func AddSingletonISomethingByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SINGLETON", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonISomethingByFuncWithMetadata adds a type by a custom func
func AddSingletonISomethingByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SINGLETON", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientISomething adds a type that implements ISomething
func AddTransientISomething(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("TRANSIENT", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "type",
		})

	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientISomethingWithMetadata adds a type that implements ISomething
func AddTransientISomethingWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("TRANSIENT", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientISomethingByFunc adds a type by a custom func
func AddTransientISomethingByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("TRANSIENT", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "func",
		})

	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientISomethingByFuncWithMetadata adds a type by a custom func
func AddTransientISomethingByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("TRANSIENT", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedISomething adds a type that implements ISomething
func AddScopedISomething(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SCOPED", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedISomethingWithMetadata adds a type that implements ISomething
func AddScopedISomethingWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SCOPED", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedISomethingByFunc adds a type by a custom func
func AddScopedISomethingByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SCOPED", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedISomethingByFuncWithMetadata adds a type by a custom func
func AddScopedISomethingByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething)
	_logAddISomething("SCOPED", implType, _getImplementedISomethingNames(implementedTypes...),
		_logISomethingExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomethingExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllISomething removes all ISomething from the DI
func RemoveAllISomething(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeISomething)
}

// GetISomethingFromContainer alternative to SafeGetISomethingFromContainer but panics of object is not present
func GetISomethingFromContainer(ctn di.Container) ISomething {
	return ctn.GetByType(ReflectTypeISomething).(ISomething)
}

// GetManyISomethingFromContainer alternative to SafeGetManyISomethingFromContainer but panics of object is not present
func GetManyISomethingFromContainer(ctn di.Container) []ISomething {
	objs := ctn.GetManyByType(ReflectTypeISomething)
	var results []ISomething
	for _, obj := range objs {
		results = append(results, obj.(ISomething))
	}
	return results
}

// SafeGetISomethingFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetISomethingFromContainer(ctn di.Container) (ISomething, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeISomething)
	if err != nil {
		return nil, err
	}
	return obj.(ISomething), nil
}

// GetISomethingDefinition returns that last definition registered that this container can provide
func GetISomethingDefinition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeISomething)
	return def
}

// GetISomethingDefinitions returns all definitions that this container can provide
func GetISomethingDefinitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeISomething)
	return defs
}

// SafeGetManyISomethingFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyISomethingFromContainer(ctn di.Container) ([]ISomething, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeISomething)
	if err != nil {
		return nil, err
	}
	var results []ISomething
	for _, obj := range objs {
		results = append(results, obj.(ISomething))
	}
	return results, nil
}

type _logISomethingExtra struct {
	Name  string
	Value interface{}
}

func _logAddISomething(scopeType string, implType reflect.Type, interfaces string, extra ..._logISomethingExtra) {
	infoEvent := log.Info().
		Str("DI", scopeType).
		Str("DI-I", interfaces).
		Str("DI-B", implType.Elem().String())

	for _, extra := range extra {
		infoEvent = infoEvent.Interface(extra.Name, extra.Value)
	}

	infoEvent.Send()

}
func _getImplementedISomethingNames(implementedTypes ...reflect.Type) string {
	builder := strings.Builder{}
	for idx, implementedType := range implementedTypes {
		builder.WriteString(implementedType.Name())
		if idx < len(implementedTypes)-1 {
			builder.WriteString(", ")
		}
	}
	return builder.String()
}

// ReflectTypeISomething2 used when your service claims to implement ISomething2
var ReflectTypeISomething2 = di.GetInterfaceReflectType((*ISomething2)(nil))

// AddSingletonISomething2 adds a type that implements ISomething2
func AddSingletonISomething2(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SINGLETON", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonISomething2WithMetadata adds a type that implements ISomething2
func AddSingletonISomething2WithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SINGLETON", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonISomething2ByObj adds a prebuilt obj
func AddSingletonISomething2ByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SINGLETON", reflect.TypeOf(obj), _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "obj",
		})
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonISomething2ByObjWithMetadata adds a prebuilt obj
func AddSingletonISomething2ByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SINGLETON", reflect.TypeOf(obj), _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "obj",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonISomething2ByFunc adds a type by a custom func
func AddSingletonISomething2ByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SINGLETON", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonISomething2ByFuncWithMetadata adds a type by a custom func
func AddSingletonISomething2ByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SINGLETON", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientISomething2 adds a type that implements ISomething2
func AddTransientISomething2(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("TRANSIENT", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "type",
		})

	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientISomething2WithMetadata adds a type that implements ISomething2
func AddTransientISomething2WithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("TRANSIENT", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientISomething2ByFunc adds a type by a custom func
func AddTransientISomething2ByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("TRANSIENT", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "func",
		})

	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientISomething2ByFuncWithMetadata adds a type by a custom func
func AddTransientISomething2ByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("TRANSIENT", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedISomething2 adds a type that implements ISomething2
func AddScopedISomething2(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SCOPED", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedISomething2WithMetadata adds a type that implements ISomething2
func AddScopedISomething2WithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SCOPED", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedISomething2ByFunc adds a type by a custom func
func AddScopedISomething2ByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SCOPED", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedISomething2ByFuncWithMetadata adds a type by a custom func
func AddScopedISomething2ByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething2)
	_logAddISomething2("SCOPED", implType, _getImplementedISomething2Names(implementedTypes...),
		_logISomething2Extra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomething2Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllISomething2 removes all ISomething2 from the DI
func RemoveAllISomething2(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeISomething2)
}

// GetISomething2FromContainer alternative to SafeGetISomething2FromContainer but panics of object is not present
func GetISomething2FromContainer(ctn di.Container) ISomething2 {
	return ctn.GetByType(ReflectTypeISomething2).(ISomething2)
}

// GetManyISomething2FromContainer alternative to SafeGetManyISomething2FromContainer but panics of object is not present
func GetManyISomething2FromContainer(ctn di.Container) []ISomething2 {
	objs := ctn.GetManyByType(ReflectTypeISomething2)
	var results []ISomething2
	for _, obj := range objs {
		results = append(results, obj.(ISomething2))
	}
	return results
}

// SafeGetISomething2FromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetISomething2FromContainer(ctn di.Container) (ISomething2, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeISomething2)
	if err != nil {
		return nil, err
	}
	return obj.(ISomething2), nil
}

// GetISomething2Definition returns that last definition registered that this container can provide
func GetISomething2Definition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeISomething2)
	return def
}

// GetISomething2Definitions returns all definitions that this container can provide
func GetISomething2Definitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeISomething2)
	return defs
}

// SafeGetManyISomething2FromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyISomething2FromContainer(ctn di.Container) ([]ISomething2, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeISomething2)
	if err != nil {
		return nil, err
	}
	var results []ISomething2
	for _, obj := range objs {
		results = append(results, obj.(ISomething2))
	}
	return results, nil
}

type _logISomething2Extra struct {
	Name  string
	Value interface{}
}

func _logAddISomething2(scopeType string, implType reflect.Type, interfaces string, extra ..._logISomething2Extra) {
	infoEvent := log.Info().
		Str("DI", scopeType).
		Str("DI-I", interfaces).
		Str("DI-B", implType.Elem().String())

	for _, extra := range extra {
		infoEvent = infoEvent.Interface(extra.Name, extra.Value)
	}

	infoEvent.Send()

}
func _getImplementedISomething2Names(implementedTypes ...reflect.Type) string {
	builder := strings.Builder{}
	for idx, implementedType := range implementedTypes {
		builder.WriteString(implementedType.Name())
		if idx < len(implementedTypes)-1 {
			builder.WriteString(", ")
		}
	}
	return builder.String()
}

// ReflectTypeISomething3 used when your service claims to implement ISomething3
var ReflectTypeISomething3 = di.GetInterfaceReflectType((*ISomething3)(nil))

// AddSingletonISomething3 adds a type that implements ISomething3
func AddSingletonISomething3(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SINGLETON", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonISomething3WithMetadata adds a type that implements ISomething3
func AddSingletonISomething3WithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SINGLETON", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonISomething3ByObj adds a prebuilt obj
func AddSingletonISomething3ByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SINGLETON", reflect.TypeOf(obj), _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "obj",
		})
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonISomething3ByObjWithMetadata adds a prebuilt obj
func AddSingletonISomething3ByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SINGLETON", reflect.TypeOf(obj), _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "obj",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonISomething3ByFunc adds a type by a custom func
func AddSingletonISomething3ByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SINGLETON", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonISomething3ByFuncWithMetadata adds a type by a custom func
func AddSingletonISomething3ByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SINGLETON", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientISomething3 adds a type that implements ISomething3
func AddTransientISomething3(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("TRANSIENT", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "type",
		})

	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientISomething3WithMetadata adds a type that implements ISomething3
func AddTransientISomething3WithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("TRANSIENT", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientISomething3ByFunc adds a type by a custom func
func AddTransientISomething3ByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("TRANSIENT", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "func",
		})

	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientISomething3ByFuncWithMetadata adds a type by a custom func
func AddTransientISomething3ByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("TRANSIENT", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedISomething3 adds a type that implements ISomething3
func AddScopedISomething3(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SCOPED", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedISomething3WithMetadata adds a type that implements ISomething3
func AddScopedISomething3WithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SCOPED", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedISomething3ByFunc adds a type by a custom func
func AddScopedISomething3ByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SCOPED", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedISomething3ByFuncWithMetadata adds a type by a custom func
func AddScopedISomething3ByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeISomething3)
	_logAddISomething3("SCOPED", implType, _getImplementedISomething3Names(implementedTypes...),
		_logISomething3Extra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logISomething3Extra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllISomething3 removes all ISomething3 from the DI
func RemoveAllISomething3(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeISomething3)
}

// GetISomething3FromContainer alternative to SafeGetISomething3FromContainer but panics of object is not present
func GetISomething3FromContainer(ctn di.Container) ISomething3 {
	return ctn.GetByType(ReflectTypeISomething3).(ISomething3)
}

// GetManyISomething3FromContainer alternative to SafeGetManyISomething3FromContainer but panics of object is not present
func GetManyISomething3FromContainer(ctn di.Container) []ISomething3 {
	objs := ctn.GetManyByType(ReflectTypeISomething3)
	var results []ISomething3
	for _, obj := range objs {
		results = append(results, obj.(ISomething3))
	}
	return results
}

// SafeGetISomething3FromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetISomething3FromContainer(ctn di.Container) (ISomething3, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeISomething3)
	if err != nil {
		return nil, err
	}
	return obj.(ISomething3), nil
}

// GetISomething3Definition returns that last definition registered that this container can provide
func GetISomething3Definition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeISomething3)
	return def
}

// GetISomething3Definitions returns all definitions that this container can provide
func GetISomething3Definitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeISomething3)
	return defs
}

// SafeGetManyISomething3FromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyISomething3FromContainer(ctn di.Container) ([]ISomething3, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeISomething3)
	if err != nil {
		return nil, err
	}
	var results []ISomething3
	for _, obj := range objs {
		results = append(results, obj.(ISomething3))
	}
	return results, nil
}

type _logISomething3Extra struct {
	Name  string
	Value interface{}
}

func _logAddISomething3(scopeType string, implType reflect.Type, interfaces string, extra ..._logISomething3Extra) {
	infoEvent := log.Info().
		Str("DI", scopeType).
		Str("DI-I", interfaces).
		Str("DI-B", implType.Elem().String())

	for _, extra := range extra {
		infoEvent = infoEvent.Interface(extra.Name, extra.Value)
	}

	infoEvent.Send()

}
func _getImplementedISomething3Names(implementedTypes ...reflect.Type) string {
	builder := strings.Builder{}
	for idx, implementedType := range implementedTypes {
		builder.WriteString(implementedType.Name())
		if idx < len(implementedTypes)-1 {
			builder.WriteString(", ")
		}
	}
	return builder.String()
}
